stages:
  - quality
  - test
  - build
  - deploy

variables:
  # PostgreSQL service config (for PHPUnit functional tests)
  POSTGRES_DB: scanarr_test
  POSTGRES_USER: scanarr
  POSTGRES_PASSWORD: scanarr
  # Composer
  COMPOSER_HOME: /tmp/composer

# ---------------------------------------------------------------------------
# Templates
# ---------------------------------------------------------------------------

.php-base:
  image: php:8.3-cli-alpine
  before_script:
    - apk add --no-cache postgresql-dev icu-dev libzip-dev $PHPIZE_DEPS
    - docker-php-ext-install pdo_pgsql intl zip > /dev/null 2>&1
    - curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer
    - cd api && composer install --no-interaction --prefer-dist --quiet
  cache:
    key: composer-${CI_COMMIT_REF_SLUG}
    paths:
      - api/vendor/

.only-tags:
  rules:
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+/

# ---------------------------------------------------------------------------
# Stage: quality
# ---------------------------------------------------------------------------

php-cs-fixer:
  extends: .php-base
  stage: quality
  script:
    - cd api && vendor/bin/php-cs-fixer fix --dry-run --diff --using-cache=no
  allow_failure: false

rector:
  extends: .php-base
  stage: quality
  script:
    - cd api && vendor/bin/rector process --dry-run
  allow_failure: false

phpmd:
  extends: .php-base
  stage: quality
  script:
    - cd api && vendor/bin/phpmd src text phpmd.xml
  allow_failure: true

# ---------------------------------------------------------------------------
# Stage: test
# ---------------------------------------------------------------------------

phpstan:
  extends: .php-base
  stage: test
  script:
    - cd api && vendor/bin/phpstan analyse --no-progress --memory-limit=512M

phpunit:
  extends: .php-base
  stage: test
  services:
    - name: postgres:16-alpine
      alias: db
  variables:
    DATABASE_URL: "postgresql://scanarr:scanarr@db:5432/scanarr_test?serverVersion=16&charset=utf8"
    APP_ENV: test
    APP_SECRET: ci_test_secret
    JWT_PASSPHRASE: ci_test_passphrase
  before_script:
    - apk add --no-cache postgresql-dev icu-dev libzip-dev openssl $PHPIZE_DEPS
    - docker-php-ext-install pdo_pgsql intl zip > /dev/null 2>&1
    - curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer
    - cd api && composer install --no-interaction --prefer-dist --quiet
    # Generate JWT keys for tests
    - mkdir -p config/jwt
    - openssl genpkey -out config/jwt/private.pem -aes256 -algorithm rsa -pkeyopt rsa_keygen_bits:2048 -pass pass:ci_test_passphrase 2>/dev/null
    - openssl pkey -in config/jwt/private.pem -out config/jwt/public.pem -pubout -passin pass:ci_test_passphrase 2>/dev/null
    - chmod 644 config/jwt/*.pem
    # Wait for DB and run migrations
    - until php -r "new PDO('pgsql:host=db;port=5432;dbname=scanarr_test', 'scanarr', 'scanarr');" 2>/dev/null; do sleep 1; done
    - php bin/console doctrine:migrations:migrate --no-interaction --env=test
  script:
    - cd api && php vendor/bin/phpunit --colors=always
  artifacts:
    when: always
    reports:
      junit: api/var/log/junit.xml

vitest:
  image: node:20-alpine
  stage: test
  before_script:
    - cd front && npm ci --prefer-offline
  script:
    - cd front && npx vitest run --reporter=default
  cache:
    key: npm-${CI_COMMIT_REF_SLUG}
    paths:
      - front/node_modules/

go-test:
  image: golang:1.22-alpine
  stage: test
  script:
    - cd watcher && go test ./... -v -count=1
  cache:
    key: go-${CI_COMMIT_REF_SLUG}
    paths:
      - /go/pkg/mod/

# ---------------------------------------------------------------------------
# Stage: build (tags only)
# ---------------------------------------------------------------------------

build-api:
  stage: build
  image: docker:27
  services:
    - docker:27-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_BUILDKIT: "1"
  extends: .only-tags
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    # Pull previous image to use as layer cache
    - docker pull $CI_REGISTRY_IMAGE/api:latest || true
    - >
      docker build
      --cache-from $CI_REGISTRY_IMAGE/api:latest
      -t $CI_REGISTRY_IMAGE/api:$CI_COMMIT_TAG
      -t $CI_REGISTRY_IMAGE/api:latest
      api/
    - docker push $CI_REGISTRY_IMAGE/api:$CI_COMMIT_TAG
    - docker push $CI_REGISTRY_IMAGE/api:latest

build-front:
  stage: build
  image: docker:27
  services:
    - docker:27-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_BUILDKIT: "1"
  extends: .only-tags
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    # Pull previous image to use as layer cache
    - docker pull $CI_REGISTRY_IMAGE/front:latest || true
    - >
      docker build
      --cache-from $CI_REGISTRY_IMAGE/front:latest
      -t $CI_REGISTRY_IMAGE/front:$CI_COMMIT_TAG
      -t $CI_REGISTRY_IMAGE/front:latest
      front/
    - docker push $CI_REGISTRY_IMAGE/front:$CI_COMMIT_TAG
    - docker push $CI_REGISTRY_IMAGE/front:latest

build-watcher:
  stage: build
  image: golang:1.22-alpine
  extends: .only-tags
  script:
    - cd watcher
    - CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o scanarr-watcher .
  artifacts:
    paths:
      - watcher/scanarr-watcher
    expire_in: 30 days

# ---------------------------------------------------------------------------
# Stage: deploy (tags only)
# ---------------------------------------------------------------------------

deploy-prod:
  stage: deploy
  image: alpine:latest
  extends: .only-tags
  needs:
    - build-api
    - build-front
  before_script:
    - apk add --no-cache openssh-client curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh && chmod 700 ~/.ssh
    - ssh-keyscan -H $DEPLOY_HOST >> ~/.ssh/known_hosts 2>/dev/null
  script:
    - |
      ssh $DEPLOY_USER@$DEPLOY_HOST << ENDSSH
        set -e
        cd $DEPLOY_PATH

        # Login to GitLab Container Registry
        echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY

        # Pull new images
        export TAG=$CI_COMMIT_TAG
        export REGISTRY_IMAGE=$CI_REGISTRY_IMAGE
        docker compose -f docker-compose.yml -f docker-compose.prod.yml pull api front

        # Deploy (--no-build ensures we use pulled images, not local build)
        docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --no-build --remove-orphans

        # Cleanup old images
        docker image prune -f

        # Health check (wait up to 30s)
        for i in \$(seq 1 30); do
          if curl -sf http://localhost:8080/api/v1/auth/setup-status > /dev/null 2>&1; then
            echo "✅ API is healthy"
            exit 0
          fi
          sleep 1
        done
        echo "❌ Health check failed"
        exit 1
      ENDSSH
  environment:
    name: production
    url: https://$DEPLOY_HOST
